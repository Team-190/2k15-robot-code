// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc190.FRC2k15.subsystems;

import org.usfirst.frc190.FRC2k15.RobotMap;
import org.usfirst.frc190.FRC2k15.commands.RegularDrive;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Drivetrain extends Subsystem {
	private boolean isFieldOriented = true;
	private boolean isSquaredInputs = false;
	private int drivingMode = 0;
	private double IRRangeLimit = 1.5; //voltage of the ir when within range (greater than this tote in range)
	// 0 = One Joystick
	// 1 = Two Joysticks, second joystick has X for Rotation
	// 2 = Two Joysticks, second joystick has Y for Rotation
	// 3 = Two Joysticks, second joystick has Z for Rotation

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Encoder backLeftEncoder = RobotMap.drivetrainbackLeftEncoder;
    Encoder frontLeftEncoder = RobotMap.drivetrainfrontLeftEncoder;
    Encoder backRightEncoder = RobotMap.drivetrainbackRightEncoder;
    Encoder frontRightEncoder = RobotMap.drivetrainfrontRightEncoder;
    Gyro gyro = RobotMap.drivetrainGyro;
    DigitalInput leftLimit = RobotMap.drivetrainleftLimit;
    DigitalInput rightLimit = RobotMap.drivetrainrightLimit;
    AnalogInput leftIR = RobotMap.drivetrainLeftIR;
    AnalogInput rightIR = RobotMap.drivetrainRightIR;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	RobotDrive robotDriveObject = RobotMap.drivetrainRobotDriveObject;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new RegularDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void MecanumDrive(double xSpeed, double ySpeed, double rSpeed,
			double heading) { //field oriented mecanum drive 
		robotDriveObject
				.mecanumDrive_Cartesian(xSpeed, ySpeed, rSpeed, heading);
	}

	public void MecanumDrivePolar(double speed, double direction,
			double rotation) { //non field oriented mecanum drive
		robotDriveObject.mecanumDrive_Polar(speed, direction, rotation);
	}

	public double getHeading() { //gets the angle of the gyroscope
		return gyro.getAngle();
	}

	public void resetGyro() { //resets the gyroscope angle
		gyro.reset();
	}

	public void setDrivingMode(int inDrivingMode) { //sets the driving mode for tele operated drive
		drivingMode = inDrivingMode;
	}

	public int getDrivingMode() { //gets the driving mode for tele operated drive
		return drivingMode;
	}

	public boolean getLeftBumper() { //returns the left bumper
		return !leftLimit.get(); //true if pressed false if not
	}

	public boolean getRightBumper() { //returns the right bumper
		return !rightLimit.get(); //true if pressed false if not
	}

	public void setFieldOriented() { //sets the teleoperated drive to field oriented
		isFieldOriented = true;
	}

	public void setRobotOriented() { //sets the teleoperated drive to robot oriented
		isFieldOriented = false;
	}

	public void setFieldOriented(boolean inIsFieldOriented) { //sets the teleoperated drive to inIsFieldOriented
		isFieldOriented = inIsFieldOriented; //true is field oriented false is not
	}

	public boolean isFieldOriented() { //returns the field oriented status of the robot
		return isFieldOriented;//true is field oriented false is not
	}

	public void setSquaredInputs(boolean inIsSquredInputs) { //sets the teleoperated drive inputs to squared
		isSquaredInputs = inIsSquredInputs; //true is squared false is non squared
	}

	public boolean isSquaredInputs() { //returns the squared inputs status
		return isSquaredInputs; //true is squared false is non squared
	}
	public void displaySensorData(){ //displays the sensor data to the SmartDashboard
		SmartDashboard.putNumber("Left IR", leftIR.getVoltage());
		SmartDashboard.putNumber("Right IR", rightIR.getVoltage());
		SmartDashboard.putBoolean("Left Bumper", leftLimit.get());
		SmartDashboard.putBoolean("Right bumper", rightLimit.get());
	}
	public boolean getLeftIRWithinRange(){ //returns if the left ir is clear (false means tote within range)
		return leftIR.getVoltage()<IRRangeLimit;
	}
	public boolean getRightIRWithinRange(){//returns if the right ir is clear (false means tote within range)
		return rightIR.getVoltage()<IRRangeLimit;
	}
	public void resetEncoders(){
		backLeftEncoder.reset();
		backRightEncoder.reset();
		frontLeftEncoder.reset();
		frontRightEncoder.reset();
	}
	//returns the distance the robot has traveled in inches
	//assumes the robot hasn't rotated
	//only returns a positive number
	public double getDistance(){
		
		double a = frontLeftEncoder.getDistance();
		double b = frontRightEncoder.getDistance();
		double c = backLeftEncoder.getDistance();
		double d = backRightEncoder.getDistance();
		
		double dist = (0.25) * (Math.sqrt(Math.pow((a - c), 2) + Math.pow((a + c), 2)) + 
					Math.sqrt(Math.pow((b - d), 2) + Math.pow((b + d), 2)));
		
		SmartDashboard.putNumber("Current Distance", dist);
		
		return dist;
	}
}
